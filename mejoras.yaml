PROMPT PARA EL AGENTE DE CÓDIGO

Rol: Eres un Senior Full-Stack Engineer con acceso al repo de CopilotOS (Next.js/React/TypeScript + Tailwind + FastAPI). Tu objetivo es estabilizar login/registro/logout/login, clarificar errores, simplificar el login/register UI, corregir historial de conversaciones, y mostrar solo Web Search y Deep Research como tools visibles. Todo lo demás quedará oculto tras feature flags. Entrega cambios testeados end-to-end.

0) Reglas de trabajo

Mantén commits atómicos por tema: auth/, ui/, history/, tools/, theme/.

Escribe pruebas donde aplique (Vitest/RTL en frontend; Pytest en backend).

Deja logs claros y feature flags (env vars) para activar/desactivar Deep Research por defecto.

No agregues dependencias innecesarias. Si debes hacerlo, justifica en el PR.

A) AUTENTICACIÓN: reparar flujo y errores

Síntoma reportado

Registro de usuario falla con mensajes genéricos (“Validation error”) sin decir la causa real.

Tras sign-up → logout → login, credenciales “no coinciden” o el hash/verify es inconsistente.

Objetivo

Registro y login confiables, con mensajes explícitos y consistentes.

Evitar doble hash, mismatch de sal y algoritmo, o verificación invertida.

Después de registro exitoso: o inicias sesión automática, o rediriges al login con toast claro (elige una y sé consistente).

Acciones

Backend (FastAPI)

Localiza las funciones de hash y verify (probablemente utils/security.py o similar).

Estándar: usa argon2 o bcrypt (elige uno y aplícalo en toda la base de código).

Si hay usuarios previos con algoritmo distinto, implementa migración de hash perezosa:

Al hacer login, si detectas formato/hash antiguo y la password valida con el verificador antiguo, re-graba al nuevo algoritmo.

Revisa que NO se esté hasheando dos veces en el flujo de registro.

Asegura constant_time_compare al verificar.

Normaliza códigos y payloads de error:

409 CONFLICT: email/usuario ya existe.

400 BAD_REQUEST: campos inválidos (schema).

401 UNAUTHORIZED: credenciales incorrectas.

Devuelve códigos y claves de error semánticas:
{"code":"USER_EXISTS","field":"email"}, {"code":"BAD_CREDENTIALS"}, {"code":"WEAK_PASSWORD"}, etc.

Snippet de referencia (Python):

from fastapi import HTTPException, status
from passlib.hash import argon2

def hash_password(plain: str) -> str:
    return argon2.hash(plain)

def verify_password(plain: str, hashed: str) -> bool:
    return argon2.verify(plain, hashed)

def raise_user_exists():
    raise HTTPException(status_code=status.HTTP_409_CONFLICT,
                        detail={"code": "USER_EXISTS", "field": "email"})


Frontend (Next.js/React)

En api client centraliza fetchers y mapea códigos de error → mensajes UX:

USER_EXISTS → “Ya existe una cuenta con ese correo.”

BAD_CREDENTIALS → “Correo o contraseña incorrectos.”

WEAK_PASSWORD → “Tu contraseña es demasiado débil (mínimo 8, 1 mayús, 1 número).”

Asegúrate de no enviar contraseñas transformadas; sólo el string plano por HTTPS.

Tras login exitoso: guarda sesión/token de manera consistente (Cookies HttpOnly si ya existe; caso contrario localStorage con refresh flow). Desactiva cache de página de auth (export const dynamic = 'force-dynamic' o no-store en fetch) para evitar estados viejos.

Flujos a validar (tests E2E con Playwright o RTL)

Sign-up con email nuevo → éxito → redirección planificada.

Sign-up con email existente → 409/USER_EXISTS y mensaje claro.

Login con credenciales válidas tras un logout → éxito consistente.

Login con credenciales inválidas → 401/BAD_CREDENTIALS.

Sesión persiste tras recargar. Logout limpia sesión.

B) UI DE LOGIN/REGISTER: minimalista y legible

Síntomas

Texto en inputs se ve en blanco sobre blanco; no legible.

Pantalla de registro muestra tres banners (Acceso/Seguridad/Documentación) que distraen.

Objetivo

Pantalla limpia: solo “CopilotOS” arriba y el formulario centrado.

Contraste suficiente y estados de error claros.

Acciones

Tema/Design tokens (styles/theme.ts o tailwind config)

Define variables:
--bg: #0B1217; --panel: #121A21; --text: #E6E8EB; --muted: #9AA4AF; --accent: #16A34A;

Inputs:

Texto text-gray-200

Placeholder placeholder-gray-400

Fondo bg-[#11161c]

Borde normal border-gray-700, foco focus:border-[#16A34A] focus:ring-[#16A34A]

Errores: borde border-red-500, helper text rojo pequeño bajo el input.

Layout

Elimina/oculta banners de características en Register.

Componente AuthCard centrado máx 420px; título “Iniciar sesión” / “Crear cuenta”.

Botón principal verde bg-[#16A34A] + hover:opacity-90 + deshabilitado gris.

Mensajería de error

Inline por campo (cuando field presente) y alerta superior contextual cuando aplica.

No uses “Validation error” genérico.

C) TOOLS: visibles solo las funcionales

Objetivo

Dejar visibles al inicio Web Search y Deep Research.

Ocultar Add files, Google Drive, Canvas, Agent mode (no borrar; dejar detrás de feature flags).

Acciones

Implementa feature flags por env vars:

NEXT_PUBLIC_FEATURE_WEB_SEARCH=true
NEXT_PUBLIC_FEATURE_DEEP_RESEARCH=true
NEXT_PUBLIC_FEATURE_ADD_FILES=false
NEXT_PUBLIC_FEATURE_GOOGLE_DRIVE=false
NEXT_PUBLIC_FEATURE_CANVAS=false
NEXT_PUBLIC_FEATURE_AGENT_MODE=false


El micrófono se oculta si no hay pipeline de audio:

Flag: NEXT_PUBLIC_FEATURE_MIC=false.

Deep Research por defecto: OFF.

Solo se activa cuando el usuario lo selecciona en Tools.

Agrega interruptor claro en el command bar y etiqueta “Deep Research” con badge ON/OFF.

D) HISTORIAL DE CONVERSACIONES: selección y render correctos

Síntoma

El historial aparece, pero al seleccionar una conversación no cambia el panel; parece volver a la misma.

Causas típicas

Estado global no actualiza activeConversationId.

Falta key estable en lista o memo mal aplicado.

Llamada de carga no depende del nuevo id.

Acciones

Estado

Usa un store (Zustand/Context) con:

type ChatState = {
  conversations: ConversationSummary[];
  activeId?: string;
  setActive: (id: string) => void;
}


Selector

En el onClick del item: setActive(id).

Lista con key={conv.id}.

Carga

useEffect(() => { fetchMessages(activeId) }, [activeId]).

Asegúrate de cancelar fetch anterior si cambia activeId.

UI

Resalta item activo.

Título del panel toma el del activeId.

Botón “Iniciar conversación”

Cambia a verde (misma variable --accent) y arregla el bug donde “no se quita” el panel vacío al iniciar: cuando se crea una conversación nueva, establece activeId = newId y navega al panel de chat.

Pruebas

Seleccionar diferentes conversaciones cambia mensajes.

Crear nueva conversación la hace activa.

Recargar conserva activeId (persistencia opcional en localStorage).

E) APAGAR “DEEP RESEARCH POR DEFECTO”

Acciones

Si hoy se dispara al enviar cualquier prompt:

Envía deep=false por defecto en el payload o no incluyas la clave que lo activa.

Asegura que la UI no muestre banners automáticos de “Starting deep research…” salvo que el usuario lo active.

Agrega texto de ayuda: “Investiga a fondo” solo cuando esté ON.

F) LIMPIEZA Y ACCESIBILIDAD

Remueve componentes no funcionales del DOM (no solo display:none) si interfieren con foco/tabindex.

aria-invalid, aria-describedby para inputs con error.

Estados loading deshabilitan botones y muestran spinner discreto.

G) ENTREGABLES

PRs por módulo con descripción técnica y antes/después en screenshots.

.env.example con feature flags.

Docs cortas en docs/UX-Auth-And-Tools.md explicando:

Mapa de errores backend → mensajes UI.

Cómo activar/desactivar Deep Research.

Cómo añadir nuevas tools tras flags.

Tests que cubran flujos clave (auth + history).

H) CHECKLIST DE ACEPTACIÓN (debe pasar todo)

 Registro con correo existente muestra “Ya existe una cuenta con ese correo.”

 Login tras logout funciona con las credenciales recién creadas.

 Mensajes de error son específicos (sin “Validation error” genérico).

 UI de login/register minimalista: sin banners; texto y placeholders legibles.

 Solo se muestran Web Search y Deep Research; micrófono oculto.

 Deep Research NO se ejecuta por defecto.

 Historial: seleccionar conversación cambia el panel; crear conversación nueva la activa; botón “Iniciar conversación” es verde y no se queda “buggeado”.

 PRs con screenshots y pruebas corriendo.

I) PISTAS DE IMPLEMENTACIÓN (fragmentos útiles)

Mapeo de errores en el cliente

const ERROR_MAP: Record<string, string> = {
  USER_EXISTS: "Ya existe una cuenta con ese correo.",
  BAD_CREDENTIALS: "Correo o contraseña incorrectos.",
  WEAK_PASSWORD: "Tu contraseña es demasiado débil.",
};

function messageFromError(e: any) {
  const code = e?.detail?.code || e?.code;
  return ERROR_MAP[code] ?? "Ocurrió un error. Intenta de nuevo.";
}


Input accesible con estados

<input
  className="w-full bg-[#11161c] text-gray-200 placeholder-gray-400
             border border-gray-700 rounded-lg px-3 py-2
             focus:outline-none focus:ring-2 focus:ring-[#16A34A] focus:border-[#16A34A]
             aria-[invalid:state~=error]:border-red-500"
/>


Feature flags

export const FLAGS = {
  webSearch: process.env.NEXT_PUBLIC_FEATURE_WEB_SEARCH === 'true',
  deepResearch: process.env.NEXT_PUBLIC_FEATURE_DEEP_RESEARCH === 'true',
  mic: process.env.NEXT_PUBLIC_FEATURE_MIC === 'true',
  addFiles: process.env.NEXT_PUBLIC_FEATURE_ADD_FILES === 'true',
  googleDrive: process.env.NEXT_PUBLIC_FEATURE_GOOGLE_DRIVE === 'true',
  canvas: process.env.NEXT_PUBLIC_FEATURE_CANVAS === 'true',
  agentMode: process.env.NEXT_PUBLIC_FEATURE_AGENT_MODE === 'true',
};


Historial (carga por id)

const { activeId, setActive } = useChatStore();

useEffect(() => {
  if (!activeId) return;
  let cancelled = false;
  (async () => {
    const res = await fetch(`/api/chat/${activeId}`);
    const data = await res.json();
    if (!cancelled) setMessages(data.messages);
  })();
  return () => { cancelled = true; };
}, [activeId]);

Principio rector

Minimalismo funcional (Marco Aurelio estaría orgulloso): quita lo que no sirve, haz visibles sólo las capacidades reales, y di la verdad en los errores. Producto gana claridad, el usuario gana confianza, y tú control operativo.
