name: 🚀 Enterprise CI/CD Pipeline

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ develop, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deploy even if tests fail'
        required: false
        default: false
        type: boolean

# 🔒 Security: Environment-specific configurations
env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.10'
  PNPM_VERSION: '8'

# 🌍 Environment-specific variables
jobs:
  # ============================================================================
  # STAGE 0: Security & Validation
  # ============================================================================
  security-scan:
    name: 🔒 Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better security scanning

      - name: 🔍 Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'  # Fail on critical/high vulnerabilities

      - name: 🔐 Secret scanning
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

      - name: 📊 Upload security results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ============================================================================
  # STAGE 1: Enhanced CI with Performance & Testing
  # ============================================================================
  ci:
    name: 🧪 Enhanced CI
    runs-on: ubuntu-latest
    needs: security-scan
    if: always() && (needs.security-scan.result == 'success' || inputs.force_deploy)

    # 🎯 Strategy for parallel testing
    strategy:
      matrix:
        test-type: [unit, integration, e2e]

    services:
      mongodb:
        image: mongo:6.0
        env:
          MONGO_INITDB_ROOT_USERNAME: ${{ secrets.TEST_MONGO_USER || 'test_user' }}
          MONGO_INITDB_ROOT_PASSWORD: ${{ secrets.TEST_MONGO_PASSWORD || 'test_password' }}
          MONGO_INITDB_DATABASE: copilotos_test
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🟢 Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 🐍 Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: 📦 Setup pnpm with cache
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      # ⚡ Performance: Intelligent caching
      - name: 📦 Get pnpm store directory
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: 🚀 Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: 🐍 Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: 📦 Install dependencies
        run: |
          pnpm install --frozen-lockfile
          cd apps/api && pip install -r requirements.txt

      # 🧪 Comprehensive Testing Strategy
      - name: 🔍 Lint Frontend (Required)
        if: matrix.test-type == 'unit'
        run: |
          pnpm --filter web lint
          if [ $? -ne 0 ]; then
            echo "❌ Linting failed. Fix issues before deploying."
            exit 1
          fi

      - name: 🔍 Type Check Frontend (Required)
        if: matrix.test-type == 'unit'
        run: |
          pnpm --filter web type-check
          if [ $? -ne 0 ]; then
            echo "❌ Type checking failed. Fix type errors before deploying."
            exit 1
          fi

      - name: 🧪 Unit Tests Frontend
        if: matrix.test-type == 'unit'
        run: |
          pnpm --filter web test:coverage
          # Fail if coverage below 80%
          npx nyc check-coverage --lines 80 --functions 80 --branches 80 --statements 80
        env:
          CI: true

      - name: 🧪 Unit Tests Backend
        if: matrix.test-type == 'unit'
        run: |
          cd apps/api
          if [ -d "tests" ]; then
            pip install pytest pytest-cov pytest-asyncio
            python -m pytest tests/ -v --cov=src --cov-report=xml --cov-fail-under=80
          else
            echo "⚠️ No tests directory found, creating basic test structure"
            mkdir -p tests
            echo "# TODO: Add comprehensive tests" > tests/__init__.py
          fi
        env:
          MONGODB_URL: mongodb://${{ secrets.TEST_MONGO_USER || 'test_user' }}:${{ secrets.TEST_MONGO_PASSWORD || 'test_password' }}@localhost:27017/copilotos_test?authSource=admin
          REDIS_URL: redis://localhost:6379/0
          JWT_SECRET_KEY: ${{ secrets.TEST_JWT_SECRET || 'test-secret-key' }}

      - name: 🧪 Integration Tests
        if: matrix.test-type == 'integration'
        run: |
          cd apps/api
          if [ -d "tests/integration" ]; then
            python -m pytest tests/integration/ -v --maxfail=1
          else
            echo "⚠️ No integration tests found, creating structure"
            mkdir -p tests/integration
            echo "# TODO: Add integration tests" > tests/integration/__init__.py
          fi
        env:
          MONGODB_URL: mongodb://${{ secrets.TEST_MONGO_USER || 'test_user' }}:${{ secrets.TEST_MONGO_PASSWORD || 'test_password' }}@localhost:27017/copilotos_test?authSource=admin
          REDIS_URL: redis://localhost:6379/0

      - name: 🏗️ Build Frontend (Required)
        if: matrix.test-type == 'unit'
        run: |
          pnpm --filter web build
          if [ $? -ne 0 ]; then
            echo "❌ Build failed. Fix build errors before deploying."
            exit 1
          fi
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_URL: ${{ github.ref == 'refs/heads/main' && secrets.PRODUCTION_API_URL || secrets.STAGING_API_URL }}

      - name: 🧪 E2E Tests (Staging only)
        if: matrix.test-type == 'e2e' && github.ref == 'refs/heads/develop'
        run: |
          if [ -d "tests/e2e" ]; then
            npx playwright test --config=tests/e2e/playwright.config.js
          else
            echo "⚠️ No E2E tests found, creating structure"
            mkdir -p tests/e2e
            echo "# TODO: Add E2E tests with Playwright" > tests/e2e/README.md
          fi

      # 📊 Upload test results
      - name: 📊 Upload coverage reports
        if: matrix.test-type == 'unit'
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml,./apps/api/coverage.xml
          fail_ci_if_error: true

      - name: 📊 Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-type }}
          path: |
            coverage/
            apps/api/coverage.xml
            test-results/
            apps/web/.next/

  # ============================================================================
  # STAGE 2: Blue-Green Deployment to Staging (Vercel)
  # ============================================================================
  deploy-staging:
    name: 🌐 Deploy to Vercel (Staging)
    runs-on: ubuntu-latest
    needs: ci
    if: always() && needs.ci.result == 'success' && github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.preview-url }}

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🟢 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 📦 Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      # ⚡ Reuse cache from CI
      - name: 🚀 Restore pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}

      - name: 📦 Install dependencies
        run: pnpm install --frozen-lockfile

      - name: 🏗️ Build for staging
        run: pnpm --filter web build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_URL: ${{ secrets.STAGING_API_URL }}
          NEXT_PUBLIC_ENVIRONMENT: staging

      # 🔄 Blue-Green Deployment Strategy
      - name: 🚀 Deploy to Vercel (Blue)
        id: deploy
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: apps/web
          scope: ${{ secrets.VERCEL_ORG_ID }}
          alias-domains: staging-copilotos-bridge.vercel.app

      # 🔍 Health Check & Smoke Tests
      - name: 🔍 Health check staging deployment
        run: |
          echo "🔍 Running health checks on ${{ steps.deploy.outputs.preview-url }}"

          # Wait for deployment to be ready
          sleep 30

          # Health check with retries
          for i in {1..10}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ steps.deploy.outputs.preview-url }}" || echo "000")
            echo "Attempt $i: HTTP Status $HTTP_STATUS"

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ Staging deployment is healthy!"
              break
            fi

            if [ $i -eq 10 ]; then
              echo "❌ Staging deployment failed health check after 10 attempts"
              exit 1
            fi

            sleep 10
          done

      # 📊 Performance Testing
      - name: ⚡ Performance testing
        run: |
          echo "⚡ Running Lighthouse CI performance tests"
          npm install -g @lhci/cli

          # Create basic Lighthouse CI config
          cat > lighthouserc.js << EOF
          module.exports = {
            ci: {
              collect: {
                url: ['${{ steps.deploy.outputs.preview-url }}'],
                numberOfRuns: 3
              },
              assert: {
                assertions: {
                  'categories:performance': ['warn', {minScore: 0.8}],
                  'categories:accessibility': ['error', {minScore: 0.9}],
                  'categories:best-practices': ['warn', {minScore: 0.8}],
                  'categories:seo': ['warn', {minScore: 0.8}]
                }
              }
            }
          };
          EOF

          lhci autorun || echo "⚠️ Performance tests completed with warnings"

      - name: 📢 Staging deployment notification
        if: success()
        run: |
          echo "🎉 Staging deployment successful!"
          echo "🌐 URL: ${{ steps.deploy.outputs.preview-url }}"
          echo "🔗 Alias: https://staging-copilotos-bridge.vercel.app"

  # ============================================================================
  # STAGE 3: Blue-Green Production Deployment (Server)
  # ============================================================================
  deploy-production:
    name: 🚀 Deploy to Production (Blue-Green)
    runs-on: ubuntu-latest
    needs: ci
    if: always() && needs.ci.result == 'success' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: http://34.42.214.246

    steps:
      # 🔄 Blue-Green Deployment Strategy for Production
      - name: 🚀 Deploy to production server (Blue-Green)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: 34.42.214.246
          username: jf
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: 22
          script: |
            set -e  # Exit on any error

            # Environment setup
            BRANCH="main"
            DEPLOY_DIR="/home/jf/copilotos-bridge"
            BACKUP_DIR="/home/jf/copilotos-bridge-backup-$(date +%Y%m%d-%H%M%S)"

            echo "🚀 Starting Blue-Green deployment to production..."

            # 1. Backup current deployment (Green)
            if [ -d "$DEPLOY_DIR" ]; then
              echo "💾 Creating backup of current deployment..."
              sudo cp -r "$DEPLOY_DIR" "$BACKUP_DIR"
              echo "✅ Backup created at $BACKUP_DIR"
            fi

            # 2. Prepare Blue environment
            cd "$DEPLOY_DIR" || exit 1

            # Enhanced git handling
            echo "🔄 Updating repository..."
            git config --global --add safe.directory "$DEPLOY_DIR"

            # Force clean update
            git fetch --all
            git reset --hard origin/main
            git clean -fdx

            # 3. Build Blue environment
            echo "🏗️ Building Blue environment..."

            # Check docker-compose availability
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
              COMPOSE_CMD="docker compose"
            else
              echo "❌ Docker Compose not found"
              exit 1
            fi

            # Use fast compose if available, fallback to standard
            if [ -f "docker-compose.fast.yml" ]; then
              COMPOSE_FILE="docker-compose.fast.yml"
            else
              COMPOSE_FILE="docker-compose.yml"
            fi

            echo "🐳 Using: $COMPOSE_CMD with $COMPOSE_FILE"

            # Build with cache and parallel processing
            $COMPOSE_CMD -f $COMPOSE_FILE build --parallel

            # 4. Health check Blue environment
            echo "🔍 Testing Blue environment..."
            $COMPOSE_CMD -f $COMPOSE_FILE up -d

            # Wait for services to start
            sleep 20

            # Comprehensive health checks
            echo "🔍 Running health checks..."

            # API health check
            for i in {1..15}; do
              API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8001/api/health || echo "000")
              echo "API Health Check $i/15: $API_STATUS"

              if [ "$API_STATUS" = "200" ]; then
                echo "✅ API is healthy"
                break
              fi

              if [ $i -eq 15 ]; then
                echo "❌ API failed health check - Rolling back..."
                $COMPOSE_CMD -f $COMPOSE_FILE down
                if [ -d "$BACKUP_DIR" ]; then
                  sudo rm -rf "$DEPLOY_DIR"
                  sudo mv "$BACKUP_DIR" "$DEPLOY_DIR"
                  cd "$DEPLOY_DIR"
                  $COMPOSE_CMD -f $COMPOSE_FILE up -d
                fi
                exit 1
              fi

              sleep 5
            done

            # Web health check
            for i in {1..15}; do
              WEB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "000")
              echo "Web Health Check $i/15: $WEB_STATUS"

              if [ "$WEB_STATUS" = "200" ]; then
                echo "✅ Web is healthy"
                break
              fi

              if [ $i -eq 15 ]; then
                echo "❌ Web failed health check - Rolling back..."
                $COMPOSE_CMD -f $COMPOSE_FILE down
                if [ -d "$BACKUP_DIR" ]; then
                  sudo rm -rf "$DEPLOY_DIR"
                  sudo mv "$BACKUP_DIR" "$DEPLOY_DIR"
                  cd "$DEPLOY_DIR"
                  $COMPOSE_CMD -f $COMPOSE_FILE up -d
                fi
                exit 1
              fi

              sleep 5
            done

            # 5. Switch traffic to Blue (already done by docker-compose up)
            echo "🔄 Blue environment is now live!"

            # 6. Final verification
            echo "🔍 Final production verification..."
            FINAL_API_CHECK=$(curl -s http://localhost:8001/api/health | jq -r '.status' 2>/dev/null || echo "error")
            FINAL_WEB_CHECK=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "000")

            if [ "$FINAL_API_CHECK" = "healthy" ] && [ "$FINAL_WEB_CHECK" = "200" ]; then
              echo "🎉 Production deployment successful!"
              echo "🌐 Web: http://34.42.214.246"
              echo "🔌 API: http://34.42.214.246/api"

              # Clean old backup (keep last 3)
              find /home/jf -name "copilotos-bridge-backup-*" -type d | sort | head -n -3 | xargs rm -rf

              # Show final status
              echo "📊 Final container status:"
              $COMPOSE_CMD -f $COMPOSE_FILE ps
            else
              echo "❌ Final verification failed"
              exit 1
            fi

  # ============================================================================
  # STAGE 4: Post-Deployment Monitoring & Alerts
  # ============================================================================
  post-deployment-monitoring:
    name: 📊 Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')

    steps:
      - name: 📊 Monitor staging deployment
        if: needs.deploy-staging.result == 'success'
        run: |
          echo "📊 Monitoring staging deployment..."

          # Extended health monitoring
          for i in {1..20}; do
            RESPONSE=$(curl -s https://staging-copilotos-bridge.vercel.app/api/health || echo "failed")
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

            if echo "$RESPONSE" | grep -q "healthy"; then
              echo "[$TIMESTAMP] ✅ Staging is healthy"
            else
              echo "[$TIMESTAMP] ⚠️ Staging health check failed: $RESPONSE"
            fi

            sleep 30
          done

      - name: 📊 Monitor production deployment
        if: needs.deploy-production.result == 'success'
        run: |
          echo "📊 Monitoring production deployment..."

          # Extended health monitoring
          for i in {1..20}; do
            API_RESPONSE=$(curl -s http://34.42.214.246/api/health || echo "failed")
            WEB_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://34.42.214.246 || echo "000")
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

            if echo "$API_RESPONSE" | grep -q "healthy" && [ "$WEB_RESPONSE" = "200" ]; then
              echo "[$TIMESTAMP] ✅ Production is healthy (API: healthy, Web: $WEB_RESPONSE)"
            else
              echo "[$TIMESTAMP] ⚠️ Production issues detected (API: $API_RESPONSE, Web: $WEB_RESPONSE)"
            fi

            sleep 30
          done

      - name: 🚨 Alert on deployment issues
        if: failure()
        run: |
          echo "🚨 ALERT: Deployment monitoring detected issues!"
          echo "Please check the deployment status and logs."

          # In a real scenario, this would send alerts to:
          # - Slack/Discord webhook
          # - Email notifications
          # - PagerDuty/OpsGenie
          # - Monitoring tools (DataDog, NewRelic, etc.)